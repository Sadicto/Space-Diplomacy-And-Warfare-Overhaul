#include "stdafx.h"
#include "cWarfareSystem.h"
#include "cPlanetAttackedEvent.h"
#include "cToolInvasionStrategy.h"
#include <Spore-Mod-Utils/Include/SporeModUtils.h>
using namespace SporeModUtils;
using namespace Simulator;

/// AUTOGENERATED METHODS ///

int cWarfareSystem::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cWarfareSystem::Release() {
	return Simulator::cStrategy::Release();
}

const char* cWarfareSystem::GetName() const {
	return "Ai_Empire_Diplomacy::cWarfareSystem";
}

bool cWarfareSystem::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cWarfareSystem::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cWarfareSystem::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};

void cWarfareSystem::Initialize() {
	warfareConfig = nullptr;
	spaceCombatMetrics = nullptr;
	archetypeStrengthConfig = nullptr;
	warfareStrengthAnalyzer = nullptr;
	warfareEventDispatcher = nullptr;
	warfareEventListener = nullptr;

	PropertyListPtr managerConfigProp;

	PropManager.GetPropertyList(id("ManagerConfig"), id("SwoConfig"), managerConfigProp);

	App::Property::GetInt32(managerConfigProp.get(), 0x86C25CEA, cycleInterval);
	App::Property::GetInt32(managerConfigProp.get(), 0x9EC13ACD, minSubcycleStep);
	App::Property::GetFloat(managerConfigProp.get(), 0x0D00F9E5, activeRadius);

	App::Property::GetKey(managerConfigProp.get(), 0x0FCF340F, warfareConfigKey);
	App::Property::GetKey(managerConfigProp.get(), 0x9BD9B276, spaceCombatKey);

	App::Property::GetKey(managerConfigProp.get(), 0x38528DA6, archetypeBaseStrengthKey);
	App::Property::GetKey(managerConfigProp.get(), 0x696C4958, archetypeBonusStrengthKey);
	App::Property::GetKey(managerConfigProp.get(), 0xDAE99764, archetypeHostilityMultiplierKey);

	elapsedTime = 0;
	subcycleStep = 0;
	empiresPerSubCycle = 0;
	nextSubcycleTime = 0;
	cycle = 0;
	
}

void cWarfareSystem::Dispose() {
	
}

void cWarfareSystem::Update(int deltaTime, int deltaGameTime) {
	if (IsSpaceGame()) {
		elapsedTime += deltaGameTime;
		if (elapsedTime > cycleInterval) {
			StartWarfareCycle();
			cycle++;
			App::ConsolePrintF("warfare cycle: %d", cycle);
		}
		// Start of a subcycle.
		while (elapsedTime > nextSubcycleTime) {
			WarfareSubCycle();
			nextSubcycleTime += subcycleStep;
		}
	}
}

void cWarfareSystem::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	if (newModeID == GameModeIDs::kGameSpace) {
		warfareConfig = new cWarfareConfig(warfareConfigKey);
		spaceCombatMetrics = new cSpaceCombatMetrics(spaceCombatKey);
		archetypeStrengthConfig = new cArchetypeStrengthConfig(archetypeBaseStrengthKey, archetypeBonusStrengthKey, archetypeHostilityMultiplierKey);
		warfareStrengthAnalyzer = new cWarfareStrengthAnalyzer(warfareConfig.get(), spaceCombatMetrics.get(), archetypeStrengthConfig.get());
		warfareEventDispatcher = new cWarfareEventDispatcher();
		warfareEventListener = new cWarfareEventListener();
		MessageManager.AddListener(warfareEventListener.get(), cPlanetAttackedEvent::ID);
		empiresWarfare.clear();
		cToolStrategy* toolStrategy = ToolManager.GetStrategy(cToolInvasionStrategy::TYPE);
		cToolInvasionStrategy* toolInvasionStrategy = static_cast<cToolInvasionStrategy*>(toolStrategy);
		if (toolInvasionStrategy) {
			toolInvasionStrategy->warfareStrengthAnalyzer = warfareStrengthAnalyzer;
			toolInvasionStrategy->warfareEventDispatcher = warfareEventDispatcher;
		}

		// Randomizes the start of the first cycle to avoid being synchronized with the cycles of other managers.
		elapsedTime = Math::rand(cycleInterval / 2);
		nextSubcycleTime = 9999999;
		cycle = 0;
	}
}

void cWarfareSystem::OnModeExited(uint32_t previousModeID, uint32_t newModeID) {
	if (previousModeID == GameModeIDs::kGameSpace) {
		warfareConfig.reset();
		spaceCombatMetrics.reset();
		archetypeStrengthConfig.reset();
		warfareStrengthAnalyzer.reset();
		warfareEventDispatcher.reset();

		MessageManager.RemoveListener(warfareEventListener.get(), cPlanetAttackedEvent::ID);
		warfareEventListener.reset();
		empiresWarfare.clear();
		cToolStrategy* toolStrategy = ToolManager.GetStrategy(cToolInvasionStrategy::TYPE);
		cToolInvasionStrategy* toolInvasionStrategy = static_cast<cToolInvasionStrategy*>(toolStrategy);
		if (toolInvasionStrategy) {
			toolInvasionStrategy->warfareStrengthAnalyzer.reset();
			toolInvasionStrategy->warfareEventDispatcher.reset();
		}
	}
}

bool cWarfareSystem::WriteToXML(XmlSerializer*)
{
	return true;
}

void cWarfareSystem::WarfareSubCycle() {
	if (empireToManage != empiresWarfare.end()) {
		if (EmpireUtils::ValidNpcEmpire(empireToManage->get()->empire.get())) {
			empireToManage->get()->SelectAndAttackTargets();
		}
		++empireToManage;
	}
}

void cWarfareSystem::StartWarfareCycle() {
	empiresWarfare.clear();

	eastl::vector<cEmpirePtr> empires;
	EmpireUtils::GetEmpiresInRadius(GetActiveStarRecord()->mPosition, activeRadius, empires);
	for (cEmpirePtr empire : empires) {
		if (EmpireUtils::ValidNpcEmpire(empire.get())) {
			cEmpireWarfarePtr empireDiplomacy = new cEmpireWarfare(empire.get(), warfareConfig.get(), warfareStrengthAnalyzer.get(), warfareEventDispatcher.get());
			empiresWarfare.push_back(empireDiplomacy);
		}
	}


	
	empireToManage = empiresWarfare.begin();
	int numEmpires = empiresWarfare.size();
	int calculatedStep = cycleInterval / (numEmpires + 1);
	subcycleStep = max(calculatedStep, minSubcycleStep);
	// substract subcycleStep because the first subcycle is at subcycleStep miliseconds.
	int numSubcycles = cycleInterval / subcycleStep;
	// Division rounding up.
	empiresPerSubCycle = (numEmpires + numSubcycles - 1) / (numSubcycles);
	elapsedTime = 0;
	nextSubcycleTime = subcycleStep;
}