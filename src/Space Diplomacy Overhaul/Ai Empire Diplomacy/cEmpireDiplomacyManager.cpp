#include "stdafx.h"
#include "cEmpireDiplomacyManager.h"
#include <Spore/Simulator/ConversationResource.h>
#include <Spore/Simulator/SubSystem/CommManager.h>
#include "Spore-Mod-Utils/Include/SporeModUtils.h"

using namespace SporeModUtils;

cEmpireDiplomacyManager* cEmpireDiplomacyManager::instance = nullptr;


/// AUTOGENERATED METHODS ///

int cEmpireDiplomacyManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cEmpireDiplomacyManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cEmpireDiplomacyManager::GetName() const {
	return "HarderSpaceDiplomacy::cEmpireDiplomacyManager";
}

bool cEmpireDiplomacyManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cEmpireDiplomacyManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cEmpireDiplomacyManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};


void cEmpireDiplomacyManager::Initialize() {
	activeRadius = 60;
	cycle = 0;
	instance = this;

	PropertyListPtr generalConfiguration;

	PropManager.GetPropertyList(id("Config"), id("SdoConfig"), generalConfiguration);

	App::Property::GetInt32(generalConfiguration.get(), 0xB5BD28BA, cycleInterval);

	App::Property::GetArrayFloat(generalConfiguration.get(), 0xE9F5A508, diplomacyRange);

	App::Property::GetInt32(generalConfiguration.get(), 0x74F51B4B, maxAffinitySoftCap);

	App::Property::GetInt32(generalConfiguration.get(), 0x63812B01, minAffinitySoftCap);

	App::Property::GetInt32(generalConfiguration.get(), 0xDB025009, affinityThresholdForStableAlliance);

	App::Property::GetInt32(generalConfiguration.get(), 0x07DB4B1C, affinityThresholdForUnstableAlliance);

	App::Property::GetInt32(generalConfiguration.get(), 0x22472FA3, affinityThresholdForWar);

	App::Property::GetInt32(generalConfiguration.get(), 0xECC06D76, affinityGainForAllyOfAlly);

	App::Property::GetInt32(generalConfiguration.get(), 0xC595B63C, affinityGainForEnemyOfEnemy);

	App::Property::GetInt32(generalConfiguration.get(), 0x21D306E2, affinityGainForEnemyOfAlly);

	App::Property::GetArrayInt32(generalConfiguration.get(), 0x8DA36269, baseAggressivityByArchetype);

	App::Property::GetArrayInt32(generalConfiguration.get(), 0x51A5A369, aggressivityGrowthByPowerLevel);

	App::Property::GetBool(generalConfiguration.get(), 0xC1C6CE47, autoDeclareWarOnAllyEnemies);

	App::Property::GetBool(generalConfiguration.get(), 0xCC04E149, startsWarsWhileAtWar);

	App::Property::GetFloat(generalConfiguration.get(), 0x4BB58401, powerThresholdToAvoidWar);

	PropertyListPtr archetypesAfinitiesConfig;

	PropManager.GetPropertyList(id("ArchetypeAffinities"), id("SdoConfig"), archetypesAfinitiesConfig);
	
	int compatibilitesHash[8] = { 0x36F42279, 0x70C32FF1, 0x9526B215, 0xC225B633, 0xDD439F1C, 0x51DEC400, 0xCC6B3EFB, 0xD2A58F42 };

	for (int i = 0; i < 8; i++) {
		eastl::vector<int> affinity;
		App::Property::GetArrayInt32(archetypesAfinitiesConfig.get(), compatibilitesHash[i], affinity);
		archetypesAffinities.push_back(affinity);
	}
}

void cEmpireDiplomacyManager::Dispose() {


}

void cEmpireDiplomacyManager::Update(int deltaTime, int deltaGameTime) {
	if (IsSpaceGame()) {
		elapsedTime += deltaGameTime;
		if (elapsedTime > cycleInterval) {
			//EmpireDiplomacyCycle();
			elapsedTime = 0;
		}
	}
}

void cEmpireDiplomacyManager::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	if (newModeID == GameModeIDs::kGameSpace) {
		cycle = 0;
		elapsedTime = 0;
	}
}

bool cEmpireDiplomacyManager::WriteToXML(XmlSerializer*)
{
	return true;
}

cEmpireDiplomacyManagerPtr cEmpireDiplomacyManager::Get() {
	return instance;
}

cStarRecord* cEmpireDiplomacyManager::GetCurrentStar() {
	cStarRecord* actualStar = SpacePlayerData::Get()->mpActiveStar.get()->mpStarRecord.get();
	return actualStar;
}

void cEmpireDiplomacyManager::GetEmpiresInRadius(const Vector3& coords, float radius, eastl::vector<cEmpirePtr>& empires, bool includePlayer) {
	StarRequestFilter filter;
	filter.RemoveStarType(StarType::None);
	filter.RemoveStarType(StarType::GalacticCore);
	filter.RemoveStarType(StarType::ProtoPlanetary);
	filter.RemoveStarType(StarType::BlackHole);
	filter.techLevels = 0;
	filter.AddTechLevel(TechLevel::Empire);
	filter.minDistance = 0;
	filter.maxDistance = radius;

	eastl::vector<cStarRecordPtr> starsColonized;
	StarManager.FindStars(coords, filter, starsColonized);

	// a set prevents duplicates.
	eastl::set<uint32_t> empireIDSet;

	uint32_t groxEmpireID = StarManager.GetGrobEmpireID();
	uint32_t playerEmpireId = SpacePlayerData::Get()->mPlayerEmpireID;

	// Collect unique mEmpireID values owners if the stars, except the grox and player empire.
	for (cStarRecordPtr star : starsColonized) {
		if ((star->mEmpireID != playerEmpireId || includePlayer) && star->mEmpireID != groxEmpireID) {
			empireIDSet.insert(star->mEmpireID);
		}
	}
	//Get the empire for every id.
	for (uint32_t id : empireIDSet) {
		empires.push_back(cEmpirePtr(StarManager.GetEmpire(id)));
	}
}

float cEmpireDiplomacyManager::GetDistanceBetweenStars(cStarRecord* star1, cStarRecord* star2) {
	return (star1->mPosition - star2->mPosition).Length();
}

//new

eastl::string16 cEmpireDiplomacyManager::ArchetypeToString(Archetypes archetype) {
	switch (archetype) {
		case kArchetypeWarrior: case kArchetypePlayerWarrior: return u"Warrior";
		case kArchetypeTrader: case kArchetypePlayerTrader: return u"Trader";
		case kArchetypeScientist: case kArchetypePlayerScientist: return u"Scientist";
		case kArchetypeShaman: case kArchetypePlayerShaman: return u"Shaman";
		case kArchetypeBard: case kArchetypePlayerBard: return u"Bard";
		case kArchetypeZealot: case kArchetypePlayerZealot: return u"Zealot";
		case kArchetypeDiplomat: case kArchetypePlayerDiplomat: return u"Diplomat";
		case kArchetypeEcologist: case kArchetypePlayerEcologist: return u"Ecologist";
		case kArchetypeGrob: return u"Grob";
		case kArchetypePlayerWanderer: return u"Wanderer";
		case kArchetypePlayerKnight: return u"Knight";
		default: return u"Unknown";
	}
}

bool cEmpireDiplomacyManager::EmpireEncountered(cEmpire* empire) {
	eastl::vector<StarID> starsVisited = GetPlayer()->mStarsVisited;
	for (cStarRecordPtr star : empire->mStars){
		if (eastl::find(starsVisited.begin(), starsVisited.end(), star->GetID()) != starsVisited.end()) {
			return true;
		}
	}
	return false;
}

int cEmpireDiplomacyManager::GetEmpireLevel(cEmpire* empire) {
	return EmpireUtils::GetEmpireLevel(empire);
}

int cEmpireDiplomacyManager::GetEmpireRange(cEmpire* empire) {
	switch (GetEmpireLevel(empire)) {
	case 0:
		return 3;
	case 1:
		return 5;
	case 2:
		return 7;
	case 3:
		return 8;
	case 4:
		return 10;
	}
	//return 5 + empire->field_D8 * 2;
}

void cEmpireDiplomacyManager::GetEmpiresInRange(cEmpire* empire, eastl::vector<cEmpirePtr>& empires) {
	int empireRange = GetEmpireRange(empire);
	// a set prevents duplicates.
	eastl::set<cEmpirePtr> nearEmpiresSet;
	for (cStarRecordPtr empireStar : empire->mStars) {
		eastl::vector<cEmpirePtr> empiresAroundStar;
		Vector3 starCoordinates = empireStar->mPosition;
		GetEmpiresInRadius(starCoordinates, empireRange, empiresAroundStar, true);
		for (cEmpirePtr nearEmpire : empiresAroundStar) {
			if (nearEmpire != empire && EmpireUtils::ValidNpcEmpire(nearEmpire.get(), true)) {
				nearEmpiresSet.insert(nearEmpire);
			}
		}
	}
	for (cEmpirePtr empire : nearEmpiresSet) {
		empires.push_back(empire);
	}
}

bool cEmpireDiplomacyManager::Allied(cEmpire* empire1, cEmpire* empire2) {
	for (cEmpirePtr empireAlly : empire1->mAllies) {
		if (empireAlly.get() == empire2) {
			return true;
		}
	}
	return false;
}

bool cEmpireDiplomacyManager::AllianceWithEnemyOfEmpire(cEmpire* empire, cEmpire* target) {
	for (cEmpirePtr allyEmpire : empire->mAllies) {
		auto it = eastl::find(target->mEnemies.begin(), target->mEnemies.end(), allyEmpire);
		if (it != target->mEnemies.end()) { // an ally is an enemy of the target empire
			return true;
		}
	}
	return false;
}

int cEmpireDiplomacyManager::CommonEnemiesCount(cEmpire* empire1, cEmpire* empire2) {
	int commonEnemies = 0;
	for (cEmpirePtr enemyEmpire : empire1->mEnemies) {
		auto it = eastl::find(empire2->mEnemies.begin(), empire2->mEnemies.end(), enemyEmpire);
		if (it != empire2->mEnemies.end()) { // an enemy is an enemy of the target empire
			commonEnemies++;
		}
	}
	return commonEnemies;
}

int cEmpireDiplomacyManager::EmpireAgressivity(cEmpire* empire, cEmpire* target) {
	Archetypes archetype = empire->mArchetype;
	switch (archetype) {
		case kArchetypeShaman: return -5;
		case kArchetypeDiplomat: {
			if (AllianceWithEnemyOfEmpire(empire, target)) {
				return 0;
			}
			else {
				return -4;
			}
		}
		case kArchetypeEcologist: return -3;
		case kArchetypeBard: return Math::rand(5) - 2; //random between -2 and 2
		case kArchetypeTrader: {
			int sizeDifference = empire->mStars.size() - target->mStars.size();
			if (sizeDifference >= 5) {
				return sizeDifference % 5; // +1 aggressiveness for every 5 systems the empire has more than the target.
			}
			else {
				return 0;
			}
		}
		case kArchetypeScientist: return + 2 * max(GetEmpireLevel(empire) - GetEmpireLevel(target), 0); // +2 aggressiveness for every level the empire has more than the target.
		case kArchetypeZealot: return 3;
		case kArchetypeWarrior: return 5;
		default: return 0;
	}
	return 1;
}

int cEmpireDiplomacyManager::ArchetypeCompatibility(Archetypes archetype1, Archetypes archetype2) {
	if (archetype1 > 8) { // if the archetype is an kArchetypePlayerXXX
		archetype1 = static_cast<Archetypes>(archetype1 - 9); // convert it to an kArchetypeXXX
	}
	if (archetype2 > 8) { // if the archetype is an kArchetypePlayerXXX
		archetype2 = static_cast<Archetypes>(archetype2 - 9); // convert it to an kArchetypeXXX
	}
	// Delete after adding suport to knights and wanderers
	if (archetype1 == Archetypes::kArchetypePlayerWanderer) {
		archetype1 = Archetypes::kArchetypeDiplomat;
	}
	if (archetype2 == Archetypes::kArchetypePlayerWanderer) {
		archetype2 = Archetypes::kArchetypeDiplomat;
	}
	if (archetype1 == Archetypes::kArchetypePlayerKnight) {
		archetype1 = Archetypes::kArchetypeWarrior;
	}
	if (archetype2 == Archetypes::kArchetypePlayerKnight) {
		archetype2 = Archetypes::kArchetypeWarrior;
	}
	return archetypesAffinities[archetype1][archetype2];
}

float cEmpireDiplomacyManager::BoundedSigmoid(float x) {
	if (0 > x) {
		return 0.0f;
	}
	else {
		return min(x / 10, 1.0f);
	}
}

float cEmpireDiplomacyManager::AllianceProbability(cEmpire* empire1, cEmpire* empire2) {
	if (AllianceWithEnemyOfEmpire(empire1, empire2) || AllianceWithEnemyOfEmpire(empire2, empire1)) {
		return 0;
	}
	else {
		int CommonEnemies = CommonEnemiesCount(empire1, empire2);
		int compatibility = ArchetypeCompatibility(empire1->mArchetype, empire2->mArchetype);
		return BoundedSigmoid(2 * CommonEnemies + compatibility) / 2; // /2 because this method will almost always execute twice for a pair of empires during a cycle.
	}
}

float cEmpireDiplomacyManager::BreakAllianceProbability(cEmpire* empire1, cEmpire* empire2) {
	float pMin = 0;
	if (AllianceWithEnemyOfEmpire(empire1, empire2) || AllianceWithEnemyOfEmpire(empire2, empire1)) {
		pMin = 0.20;
	}
	int CommonEnemies = CommonEnemiesCount(empire1, empire2);
	int compatibility = ArchetypeCompatibility(empire1->mArchetype, empire2->mArchetype);
	return max(BoundedSigmoid(-3 * CommonEnemies - compatibility) / 2, pMin); // /2 because this method will almost always execute twice for a pair of empires during a cycle.
}

float cEmpireDiplomacyManager::DeclareWarProbability(cEmpire* empire, cEmpire* target) {
	float pMin = 0;
	if (AllianceWithEnemyOfEmpire(empire, target)) {
		pMin = 0.20;
	}
	int compatibility = ArchetypeCompatibility(empire->mArchetype, target->mArchetype);
	int warCount = empire->mEnemies.size();
	int level = GetEmpireLevel(empire);
	int agressivity = EmpireAgressivity(empire, target);
	int deltaLevel = GetEmpireLevel(empire) - GetEmpireLevel(target);
	return max(BoundedSigmoid ( - compatibility - 2 * warCount + level - 2 + agressivity + deltaLevel), pMin);
}

void  cEmpireDiplomacyManager::CreateTributeComm(cEmpire* empire) {
	CnvAction action;
	action.actionID = 0x4C182387;
	CommManager.HandleSpaceCommAction(action, empire->GetEmpireID(), empire->RequireHomePlanet()->GetID(), nullptr); //when the relation is blue face or better this doesn´t work
}

void cEmpireDiplomacyManager::ManageEmpireDiplomacy(cEmpire* empire) {
	uint32_t playerEmpireId = SpacePlayerData::Get()->mPlayerEmpireID;

	eastl::vector<cEmpirePtr> empiresInRange;
	GetEmpiresInRange(empire, empiresInRange);

	for (cEmpirePtr empireInRange : empiresInRange) {

		if (!RelationshipManager.IsAtWar(empire, empireInRange.get())) {

			if (Allied(empire, empireInRange.get())) {
				float pOfBreakAlliance = BreakAllianceProbability(empire, empireInRange.get());

				if (pOfBreakAlliance >= Math::randf()) {

					if (empireInRange->GetEmpireID() == playerEmpireId) {
						// maybe change it?
						RelationshipManager.BreakAlliance(empire, empireInRange.get());
					}
					else {
						RelationshipManager.BreakAlliance(empire, empireInRange.get());
					}
				}
				else if (pOfBreakAlliance == 0.0f && empireInRange->GetEmpireID() == playerEmpireId) {
					//strengthen  alliance
					RelationshipManager.ApplyRelationship(empire->GetEmpireID(), empireInRange->GetEmpireID(), kRelationshipEventSpaceCreateAlliance, 1.0f);
				}
			}
			// not ally or enemy empire.
			else {
				float pOfAlliance = AllianceProbability(empire, empireInRange.get());
				float pOfWar = DeclareWarProbability(empire, empireInRange.get());

				if (pOfWar >= pOfAlliance) {

					if (pOfWar >= Math::randf()) {
						
						if (empireInRange->GetEmpireID() == playerEmpireId) {
							CreateTributeComm(empire);
						}
						else {
							RelationshipManager.DeclareWar(empire, empireInRange.get());
						}
					}
				}
				// pOfAlliance > pOfWar
				else {
					if (pOfAlliance >= Math::randf()) {

						if (empireInRange->GetEmpireID() == playerEmpireId) {
							RelationshipManager.ApplyRelationship(empire->GetEmpireID(), empireInRange->GetEmpireID(), kRelationshipEventSpaceAcceptGift, 2.5f);
						}
						else {
							RelationshipManager.DeclareAlliance(empire, empireInRange.get());
						}
					}
				}
			}
		}
		else { // At war.
			RelationshipManager.ApplyRelationship(empire->GetEmpireID(), empireInRange->GetEmpireID(), kRelationshipEventSpaceStartedWar, 1.0f);
		}
	}

}

void cEmpireDiplomacyManager::EmpireDiplomacyCycle() {
	eastl::vector<cEmpirePtr> empires;
	GetEmpiresInRadius(GetCurrentStar()->mPosition, activeRadius, empires);

	for (cEmpirePtr empire : empires) {
		ManageEmpireDiplomacy(empire.get());
	}
	// TODO, enemies of ally.
}
