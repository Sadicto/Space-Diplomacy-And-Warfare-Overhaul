#include "stdafx.h"
#include "cEmpireDiplomacyManager.h"
#include <Spore/Simulator/ConversationResource.h>
#include <Spore/Simulator/SubSystem/CommManager.h>
#include "Spore-Mod-Utils/Include/SporeModUtils.h"

using namespace SporeModUtils;

cEmpireDiplomacyManager* cEmpireDiplomacyManager::instance = nullptr;


/// AUTOGENERATED METHODS ///

int cEmpireDiplomacyManager::AddRef() {
	return Simulator::cStrategy::AddRef();
}
int cEmpireDiplomacyManager::Release() {
	return Simulator::cStrategy::Release();
}

const char* cEmpireDiplomacyManager::GetName() const {
	return "HarderSpaceDiplomacy::cEmpireDiplomacyManager";
}

bool cEmpireDiplomacyManager::Write(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Write(stream);
}
bool cEmpireDiplomacyManager::Read(Simulator::ISerializerStream* stream)
{
	return Simulator::ClassSerializer(this, ATTRIBUTES).Read(stream);
}

/// END OF AUTOGENERATED METHODS ///
////////////////////////////////////

Simulator::Attribute cEmpireDiplomacyManager::ATTRIBUTES[] = {
	// Add more attributes here
	// This one must always be at the end
	Simulator::Attribute()
};


void cEmpireDiplomacyManager::Initialize() {
	activeRadius = 60;
	cycle = 0;
	instance = this;

	PropertyListPtr generalConfiguration;

	PropManager.GetPropertyList(id("Config"), id("SdoConfig"), generalConfiguration);

	App::Property::GetInt32(generalConfiguration.get(), 0xB5BD28BA, cycleInterval);

	App::Property::GetArrayFloat(generalConfiguration.get(), 0xE9F5A508, diplomacyRange);

	App::Property::GetInt32(generalConfiguration.get(), 0x74F51B4B, maxAffinitySoftCap);

	App::Property::GetInt32(generalConfiguration.get(), 0x63812B01, minAffinitySoftCap);

	App::Property::GetInt32(generalConfiguration.get(), 0xDB025009, affinityThresholdForStableAlliance);

	App::Property::GetInt32(generalConfiguration.get(), 0x07DB4B1C, affinityThresholdForUnstableAlliance);

	App::Property::GetInt32(generalConfiguration.get(), 0x22472FA3, affinityThresholdForWar);

	App::Property::GetInt32(generalConfiguration.get(), 0xECC06D76, affinityGainForAllyOfAlly);

	App::Property::GetInt32(generalConfiguration.get(), 0xC595B63C, affinityGainForEnemyOfEnemy);

	App::Property::GetInt32(generalConfiguration.get(), 0x21D306E2, affinityGainForEnemyOfAlly);

	App::Property::GetArrayInt32(generalConfiguration.get(), 0x8DA36269, baseAggressivityByArchetype);

	App::Property::GetArrayInt32(generalConfiguration.get(), 0x51A5A369, aggressivityGrowthByPowerLevel);

	App::Property::GetBool(generalConfiguration.get(), 0xC1C6CE47, autoDeclareWarOnAllyEnemies);

	App::Property::GetBool(generalConfiguration.get(), 0xCC04E149, startsWarsWhileAtWar);

	App::Property::GetFloat(generalConfiguration.get(), 0x4BB58401, powerThresholdToAvoidWar);

	PropertyListPtr archetypesAfinitiesConfig;

	PropManager.GetPropertyList(id("ArchetypeAffinities"), id("SdoConfig"), archetypesAfinitiesConfig);
	
	int compatibilitesHash[8] = { 0x36F42279, 0x70C32FF1, 0x9526B215, 0xC225B633, 0xDD439F1C, 0x51DEC400, 0xCC6B3EFB, 0xD2A58F42 };

	for (int i = 0; i < 8; i++) {
		eastl::vector<int> affinity;
		App::Property::GetArrayInt32(archetypesAfinitiesConfig.get(), compatibilitesHash[i], affinity);
		archetypesAffinities.push_back(affinity);
	}
}

void cEmpireDiplomacyManager::Dispose() {


}

void cEmpireDiplomacyManager::Update(int deltaTime, int deltaGameTime) {
	if (IsSpaceGame()) {
		elapsedTime += deltaGameTime;
		if (elapsedTime > cycleInterval) {
			//EmpireDiplomacyCycle();
			elapsedTime = 0;
		}
	}
}

void cEmpireDiplomacyManager::OnModeEntered(uint32_t previousModeID, uint32_t newModeID) {
	if (newModeID == GameModeIDs::kGameSpace) {
		cycle = 0;
		elapsedTime = 0;
	}
}

bool cEmpireDiplomacyManager::WriteToXML(XmlSerializer*)
{
	return true;
}

cEmpireDiplomacyManagerPtr cEmpireDiplomacyManager::Get() {
	return instance;
}

eastl::string16 cEmpireDiplomacyManager::ArchetypeToString(Archetypes archetype) {
	switch (archetype) {
		case kArchetypeWarrior: case kArchetypePlayerWarrior: return u"Warrior";
		case kArchetypeTrader: case kArchetypePlayerTrader: return u"Trader";
		case kArchetypeScientist: case kArchetypePlayerScientist: return u"Scientist";
		case kArchetypeShaman: case kArchetypePlayerShaman: return u"Shaman";
		case kArchetypeBard: case kArchetypePlayerBard: return u"Bard";
		case kArchetypeZealot: case kArchetypePlayerZealot: return u"Zealot";
		case kArchetypeDiplomat: case kArchetypePlayerDiplomat: return u"Diplomat";
		case kArchetypeEcologist: case kArchetypePlayerEcologist: return u"Ecologist";
		case kArchetypeGrob: return u"Grob";
		case kArchetypePlayerWanderer: return u"Wanderer";
		case kArchetypePlayerKnight: return u"Knight";
		default: return u"Unknown";
	}
}

float cEmpireDiplomacyManager::GetEmpireDiplomaticRange(cEmpire* empire) {
	int empireLevel = EmpireUtils::GetEmpireLevel(empire);
	return diplomacyRange[empireLevel];
}

void cEmpireDiplomacyManager::GetEmpiresInDiplomaticRange(cEmpire* empire, eastl::vector<cEmpirePtr>& empires) {
	float range = GetEmpireDiplomaticRange(empire);
	EmpireUtils::GetEmpiresInRangeOfEmpire(empire, range, empires, true);
}

int cEmpireDiplomacyManager::GetEmpireAgressivity(cEmpire* empire) {
	Archetypes archetype = ArchetypeUtils::GetBaseArchetype(empire->mArchetype);
	int agressivty = baseAggressivityByArchetype[archetype];
	agressivty += aggressivityGrowthByPowerLevel[EmpireUtils::GetEmpireLevel(empire)];
	return agressivty;
}

int cEmpireDiplomacyManager::ArchetypesAffinity(Archetypes archetype1, Archetypes archetype2) {
	return archetypesAffinities[ArchetypeUtils::GetBaseArchetype(archetype1)][ArchetypeUtils::GetBaseArchetype(archetype2)];
}

int cEmpireDiplomacyManager::EmpiresAffinity(cEmpire* empire1, cEmpire* empire2) {
	int affinity = ArchetypesAffinity(empire1->mArchetype, empire2->mArchetype);
	if (DiplomacyUtils::AllianceWithAllyOfEmpire(empire1, empire2)) {
		affinity += affinityGainForAllyOfAlly;
	}
	if (DiplomacyUtils::CommonEnemy(empire1, empire2)) {
		affinity += affinityGainForEnemyOfEnemy;
	}
	if (DiplomacyUtils::AllianceWithEnemyOfEmpire(empire1, empire2)) {
		affinity += affinityGainForEnemyOfAlly;
	}
	return affinity;
}

float cEmpireDiplomacyManager::AllianceProbability(cEmpire* empire1, cEmpire* empire2) {
	return 1.0f;
	/*
	if (DiplomacyUtils::AllianceWithEnemyOfEmpire(empire1, empire2) || DiplomacyUtils::AllianceWithEnemyOfEmpire(empire2, empire1)) {
		return 0;
	}
	else {
		int CommonEnemies = CommonEnemiesCount(empire1, empire2);
		int compatibility = ArchetypeCompatibility(empire1->mArchetype, empire2->mArchetype);
		return BoundedSigmoid(2 * CommonEnemies + compatibility) / 2; // /2 because this method will almost always execute twice for a pair of empires during a cycle.
	}
	*/
}

float cEmpireDiplomacyManager::BreakAllianceProbability(cEmpire* empire1, cEmpire* empire2) {
	return 1.0f;
	/*
	float pMin = 0;
	if (DiplomacyUtils::AllianceWithEnemyOfEmpire(empire1, empire2) || DiplomacyUtils::AllianceWithEnemyOfEmpire(empire2, empire1)) {
		pMin = 0.20;
	}
	int CommonEnemies = CommonEnemiesCount(empire1, empire2);
	int compatibility = ArchetypeCompatibility(empire1->mArchetype, empire2->mArchetype);
	return max(BoundedSigmoid(-3 * CommonEnemies - compatibility) / 2, pMin); // /2 because this method will almost always execute twice for a pair of empires during a cycle.
	*/
}

float cEmpireDiplomacyManager::DeclareWarProbability(cEmpire* empire, cEmpire* target) {
	return 1.0f;
	/*
	float pMin = 0;
	if (DiplomacyUtils::AllianceWithEnemyOfEmpire(empire, target)) {
		pMin = 0.20;
	}
	int compatibility = ArchetypeCompatibility(empire->mArchetype, target->mArchetype);
	int warCount = empire->mEnemies.size();
	int level = EmpireUtils::GetEmpireLevel(empire);
	int agressivity = EmpireAgressivity(empire, target);
	int deltaLevel = EmpireUtils::GetEmpireLevel(empire) - EmpireUtils::GetEmpireLevel(target);
	return max(BoundedSigmoid ( - compatibility - 2 * warCount + level - 2 + agressivity + deltaLevel), pMin);
	*/
}

void  cEmpireDiplomacyManager::CreateTributeComm(cEmpire* empire) {
	CnvAction action;
	action.actionID = 0x4C182387;
	CommManager.HandleSpaceCommAction(action, empire->GetEmpireID(), empire->RequireHomePlanet()->GetID(), nullptr); //when the relation is blue face or better this doesn´t work
}

void cEmpireDiplomacyManager::ManageEmpireDiplomacy(cEmpire* empire) {
	uint32_t playerEmpireId = SpacePlayerData::Get()->mPlayerEmpireID;

	eastl::vector<cEmpirePtr> empiresInRange;
	GetEmpiresInDiplomaticRange(empire, empiresInRange);

	for (cEmpirePtr empireInRange : empiresInRange) {
	}
		/*

		if (!RelationshipManager.IsAtWar(empire, empireInRange.get())) {

			if (Allied(empire, empireInRange.get())) {
				float pOfBreakAlliance = BreakAllianceProbability(empire, empireInRange.get());

				if (pOfBreakAlliance >= Math::randf()) {

					if (empireInRange->GetEmpireID() == playerEmpireId) {
						// maybe change it?
						RelationshipManager.BreakAlliance(empire, empireInRange.get());
					}
					else {
						RelationshipManager.BreakAlliance(empire, empireInRange.get());
					}
				}
				else if (pOfBreakAlliance == 0.0f && empireInRange->GetEmpireID() == playerEmpireId) {
					//strengthen  alliance
					RelationshipManager.ApplyRelationship(empire->GetEmpireID(), empireInRange->GetEmpireID(), kRelationshipEventSpaceCreateAlliance, 1.0f);
				}
			}
			// not ally or enemy empire.
			else {
				float pOfAlliance = AllianceProbability(empire, empireInRange.get());
				float pOfWar = DeclareWarProbability(empire, empireInRange.get());

				if (pOfWar >= pOfAlliance) {

					if (pOfWar >= Math::randf()) {
						
						if (empireInRange->GetEmpireID() == playerEmpireId) {
							CreateTributeComm(empire);
						}
						else {
							RelationshipManager.DeclareWar(empire, empireInRange.get());
						}
					}
				}
				// pOfAlliance > pOfWar
				else {
					if (pOfAlliance >= Math::randf()) {

						if (empireInRange->GetEmpireID() == playerEmpireId) {
							RelationshipManager.ApplyRelationship(empire->GetEmpireID(), empireInRange->GetEmpireID(), kRelationshipEventSpaceAcceptGift, 2.5f);
						}
						else {
							RelationshipManager.DeclareAlliance(empire, empireInRange.get());
						}
					}
				}
			}
		}
		else { // At war.
			RelationshipManager.ApplyRelationship(empire->GetEmpireID(), empireInRange->GetEmpireID(), kRelationshipEventSpaceStartedWar, 1.0f);
		}
	}*/

}

void cEmpireDiplomacyManager::EmpireDiplomacyCycle() {
	eastl::vector<cEmpirePtr> empires;
	EmpireUtils::GetEmpiresInRadius(GetActiveStarRecord()->mPosition, activeRadius, empires);

	for (cEmpirePtr empire : empires) {
		ManageEmpireDiplomacy(empire.get());
	}
	// TODO, enemies of ally.
}
